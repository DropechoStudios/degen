// Generated by Haxe 4.1.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["algos"] = $hx_exports["algos"] || {};
$hx_exports["dungen"] = $hx_exports["dungen"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
var Type = function() { };
Type.__name__ = "Type";
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
var UInt = {};
UInt.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
var dropecho_ds_GraphNode = $hx_exports["GraphNode"] = function(value,id) {
	this.id = id != null ? id : Std.string(Std.random(10000000));
	this.value = value;
};
dropecho_ds_GraphNode.__name__ = "dropecho.ds.GraphNode";
dropecho_ds_GraphNode.prototype = {
	id: null
	,value: null
	,graph: null
	,neighborIds: function() {
		return this.graph.neighborIds(this);
	}
	,neighbors: function(filter) {
		var n = this.graph.neighbors(this,filter);
		return n;
	}
	,edgeData: function(toId) {
		return this.graph.edgeData(this.id,toId);
	}
	,__class__: dropecho_ds_GraphNode
};
var dropecho_ds_BSPNode = $hx_exports["BSPNode"] = function(value) {
	dropecho_ds_GraphNode.call(this,value);
};
dropecho_ds_BSPNode.__name__ = "dropecho.ds.BSPNode";
dropecho_ds_BSPNode.__super__ = dropecho_ds_GraphNode;
dropecho_ds_BSPNode.prototype = $extend(dropecho_ds_GraphNode.prototype,{
	parent: null
	,left: null
	,right: null
	,createLeft: function(value) {
		return this.setLeft(new dropecho_ds_BSPNode(value));
	}
	,createRight: function(value) {
		return this.setRight(new dropecho_ds_BSPNode(value));
	}
	,setLeft: function(node) {
		this.left = node;
		node.parent = this;
		this.graph.addNode(node);
		this.graph.addUniEdge(this.id,node.id,"left");
		this.graph.addUniEdge(node.id,this.id,"parent");
		return node;
	}
	,setRight: function(node) {
		this.right = node;
		node.parent = this;
		this.graph.addNode(node);
		this.graph.addUniEdge(this.id,node.id,"right");
		this.graph.addUniEdge(node.id,this.id,"parent");
		return node;
	}
	,isLeaf: function() {
		if(this.right == null) {
			return this.left == null;
		} else {
			return false;
		}
	}
	,isRoot: function() {
		return this.parent == null;
	}
	,hasLeft: function() {
		return this.left != null;
	}
	,hasRight: function() {
		return this.right != null;
	}
	,__class__: dropecho_ds_BSPNode
});
var dropecho_ds_Graph = $hx_exports["Graph"] = function() {
	this.nodes = new haxe_ds_StringMap();
	this.edges = new haxe_ds_StringMap();
};
dropecho_ds_Graph.__name__ = "dropecho.ds.Graph";
dropecho_ds_Graph.prototype = {
	nodes: null
	,edges: null
	,createNode: function(value) {
		return this.addNode(new dropecho_ds_GraphNode(value));
	}
	,addNode: function(node) {
		this.nodes.h[node.id] = node;
		node.graph = this;
		return node;
	}
	,addUniEdge: function(nodeId,otherId,data) {
		if(Object.prototype.hasOwnProperty.call(this.edges.h,nodeId)) {
			this.edges.h[nodeId].h[otherId] = data;
		} else {
			var this1 = this.edges;
			var _g = new haxe_ds_StringMap();
			_g.h[otherId] = data;
			this1.h[nodeId] = _g;
		}
	}
	,addBiEdge: function(nodeId,otherId,data) {
		this.addUniEdge(nodeId,otherId,data);
		this.addUniEdge(otherId,nodeId,data);
	}
	,remove: function(id) {
		var _this = this.nodes;
		if(Object.prototype.hasOwnProperty.call(_this.h,id)) {
			delete(_this.h[id]);
		}
	}
	,neighbors: function(node,filter) {
		var _gthis = this;
		var _this = this.neighborIds(node,filter);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.nodes.h[_this[i]];
		}
		return result;
	}
	,neighborIds: function(node,filter) {
		var edges = this.edges.h[node.id];
		if(edges == null) {
			return [];
		}
		var _g = [];
		var _g1 = haxe_ds_StringMap.kvIterator(edges.h);
		while(_g1.hasNext()) {
			var _g2 = _g1.next();
			var id = _g2.key;
			var data = _g2.value;
			if(filter == null || filter(id,data)) {
				_g.push(id);
			} else {
				continue;
			}
		}
		var ids = _g;
		haxe_ds_ArraySort.sort(ids,Reflect.compare);
		return ids;
	}
	,edgeData: function(fromId,toId) {
		if(Object.prototype.hasOwnProperty.call(this.edges.h,fromId)) {
			return this.edges.h[fromId].h[toId];
		}
		return null;
	}
	,__class__: dropecho_ds_Graph
};
var dropecho_ds_BSPTree = $hx_exports["BSPTree"] = function(rootValue) {
	dropecho_ds_Graph.call(this);
	this.root = new dropecho_ds_BSPNode();
	this.root.value = rootValue;
	this.addNode(this.root);
};
dropecho_ds_BSPTree.__name__ = "dropecho.ds.BSPTree";
dropecho_ds_BSPTree.__super__ = dropecho_ds_Graph;
dropecho_ds_BSPTree.prototype = $extend(dropecho_ds_Graph.prototype,{
	root: null
	,getParent: function(node) {
		return this.neighbors(node,function(id,data) {
			return data == "parent";
		})[0];
	}
	,getChildren: function(node) {
		return this.neighbors(node,function(id,data) {
			if(data != "left") {
				return data == "right";
			} else {
				return true;
			}
		});
	}
	,getRoot: function() {
		return this.root;
	}
	,getLeafs: function() {
		var _g = [];
		var node = haxe_ds_StringMap.valueIterator(this.nodes.h);
		while(node.hasNext()) {
			var node1 = node.next();
			var tmp;
			if(this.getChildren(node1).length == 0) {
				tmp = node1;
			} else {
				continue;
			}
			_g.push(tmp);
		}
		return _g;
	}
	,__class__: dropecho_ds_BSPTree
});
var dropecho_ds_algos_InOrderTraversal = $hx_exports["algos"]["InOrderTraversal"] = function() {
	this.visited = [];
};
dropecho_ds_algos_InOrderTraversal.__name__ = "dropecho.ds.algos.InOrderTraversal";
dropecho_ds_algos_InOrderTraversal.prototype = {
	visited: null
	,run: function(node,visitor) {
		if(node.left != null) {
			this.run(node.left,visitor);
		}
		if(visitor != null) {
			if(visitor(node)) {
				this.visited.push(node.id);
			} else {
				return this.visited;
			}
		} else {
			this.visited.push(node.id);
		}
		if(node.right != null) {
			this.run(node.right,visitor);
		}
		return this.visited;
	}
	,__class__: dropecho_ds_algos_InOrderTraversal
};
var dropecho_ds_algos_PostOrderTraversal = $hx_exports["algos"]["PostOrderTraversal"] = function() {
	this.visited = [];
};
dropecho_ds_algos_PostOrderTraversal.__name__ = "dropecho.ds.algos.PostOrderTraversal";
dropecho_ds_algos_PostOrderTraversal.prototype = {
	visited: null
	,run: function(node,visitor) {
		if(node.left != null) {
			this.run(node.left,visitor);
		}
		if(node.right != null) {
			this.run(node.right,visitor);
		}
		if(visitor != null) {
			if(visitor(node)) {
				this.visited.push(node.id);
			} else {
				return this.visited;
			}
		} else {
			this.visited.push(node.id);
		}
		return this.visited;
	}
	,__class__: dropecho_ds_algos_PostOrderTraversal
};
var dropecho_dungen_Map2d = $hx_exports["dungen"]["Map2d"] = function(width,height,initTileData) {
	if(initTileData == null) {
		initTileData = 0;
	}
	this._height = 0;
	this._width = 0;
	this._width = width;
	this._height = height;
	this._mapData = [];
	this.initializeData(initTileData);
};
dropecho_dungen_Map2d.__name__ = "dropecho.dungen.Map2d";
dropecho_dungen_Map2d.prototype = {
	_width: null
	,_height: null
	,_mapData: null
	,initializeData: function(initTileData) {
		if(initTileData == -1) {
			return;
		}
		var _g = 0;
		var _g1 = this._height * this._width;
		while(_g < _g1) {
			var i = _g++;
			this._mapData[i] = initTileData;
		}
	}
	,ensureEdgesAreWalls: function(tileType) {
		if(tileType == null) {
			tileType = 0;
		}
		var _g = 0;
		var _g1 = this._width;
		while(_g < _g1) {
			var x = _g++;
			this._mapData[this._width * 0 + x] = tileType;
			this._mapData[this._width * (this._height - 1) + x] = tileType;
		}
		var _g = 0;
		var _g1 = this._height;
		while(_g < _g1) {
			var y = _g++;
			this._mapData[this._width * y] = tileType;
			this._mapData[this._width * y + (this._width - 1)] = tileType;
		}
	}
	,getNeighborCount: function(x,y,neighborType,dist,diagonal) {
		if(diagonal == null) {
			diagonal = true;
		}
		if(dist == null) {
			dist = 1;
		}
		var _gthis = this;
		var isNeighborType = function(tile) {
			return _gthis._mapData[_gthis._width * tile.y + tile.x] == neighborType;
		};
		return Lambda.count(this.getNeighbors(x,y,dist,diagonal),isNeighborType);
	}
	,getNeighbors: function(x,y,dist,diagonal) {
		if(diagonal == null) {
			diagonal = true;
		}
		if(dist == null) {
			dist = 1;
		}
		var neighbors = [];
		var isSelf = false;
		var isNotOnMap = false;
		var _g = -dist;
		var _g1 = dist + 1;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = -dist;
			var _g3 = dist + 1;
			while(_g2 < _g3) {
				var j = _g2++;
				isSelf = i == 0 && j == 0;
				isNotOnMap = x + i < 0 || x + i >= this._width || y + j < 0 || y + j >= this._height;
				if(isSelf || isNotOnMap) {
					continue;
				}
				if(!diagonal && (i == j || i == -dist && j == dist || j == -dist && i == dist)) {
					continue;
				}
				var val = this._mapData[this._width * (y + j) + (x + i)];
				neighbors.push({ x : x + i, y : y + j, onMap : true, val : val});
			}
		}
		return neighbors;
	}
	,XYtoIndex: function(x,y) {
		return this._width * y + x;
	}
	,IndexToXY: function(index) {
		var x = index % this._width | 0;
		var y = index / this._width | 0;
		return { x : x, y : y, onMap : x >= 0 && y >= 0 && x < this._width && y < this._height};
	}
	,set: function(x,y,data) {
		this._mapData[this._width * y + x] = data;
	}
	,setRect: function(x,y,x2,y2,data) {
		var _g = x;
		var _g1 = x2;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = y;
			var _g3 = y2;
			while(_g2 < _g3) {
				var j = _g2++;
				this._mapData[this._width * j + i] = data;
			}
		}
	}
	,splat: function(other,x,y,ignoreTile) {
		if(ignoreTile == null) {
			ignoreTile = -1;
		}
		var _g = 0;
		var _g1 = other._width;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = other._height;
			while(_g2 < _g3) {
				var j = _g2++;
				var otherTile = other._mapData[other._width * j + i];
				if(otherTile != ignoreTile) {
					this._mapData[this._width * (j + y) + (i + x)] = otherTile;
				}
			}
		}
	}
	,get: function(x,y) {
		return this._mapData[this._width * y + x];
	}
	,getRect: function(x,y,x2,y2,wrap) {
		if(wrap == null) {
			wrap = false;
		}
		var _g = [];
		var _g1 = y;
		var _g2 = y2 + 1;
		while(_g1 < _g2) {
			var j = _g1++;
			var _g3 = x;
			var _g4 = x2 + 1;
			while(_g3 < _g4) {
				var i = _g3++;
				if(wrap) {
					_g.push(this._mapData[this._width * (j % this._height) + i % this._width]);
				} else {
					_g.push(this._mapData[this._width * j + i]);
				}
			}
		}
		return _g;
	}
	,toPrettyString: function(char) {
		if(char == null) {
			char = ["#","."];
		}
		var output = "\n MAP2d: \n\n";
		var _g = 0;
		var _g1 = this._height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this._width;
			while(_g2 < _g3) {
				var x = _g2++;
				output += char[this._mapData[this._width * y + x]];
			}
			output += "\n";
		}
		return output;
	}
	,toString: function(ascii) {
		if(ascii == null) {
			ascii = false;
		}
		var output = "\n MAP2d: \n\n";
		var _g = 0;
		var _g1 = this._height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this._width;
			while(_g2 < _g3) {
				var x = _g2++;
				var val = this._mapData[this._width * y + x];
				output += val;
			}
			output += "\n";
		}
		return output;
	}
	,__class__: dropecho_dungen_Map2d
};
var dropecho_dungen_bsp_BspData = $hx_exports["dungen"]["BSPData"] = function(ops) {
	this.y = 0;
	this.x = 0;
	this.height = 0;
	this.width = 0;
	dropecho_interop_Extender.extendThis(this,ops);
};
dropecho_dungen_bsp_BspData.__name__ = "dropecho.dungen.bsp.BspData";
dropecho_dungen_bsp_BspData.prototype = {
	width: null
	,height: null
	,x: null
	,y: null
	,__class__: dropecho_dungen_bsp_BspData
};
var dropecho_dungen_bsp_BSPGeneratorConfig = $hx_exports["dungen"]["BSPGeneratorConfig"] = function() {
	this.seed = "0";
	this.y = 0;
	this.x = 0;
	this.ratio = .45;
	this.depth = 10;
	this.minWidth = 10;
	this.minHeight = 10;
	this.height = 60;
	this.width = 120;
};
dropecho_dungen_bsp_BSPGeneratorConfig.__name__ = "dropecho.dungen.bsp.BSPGeneratorConfig";
dropecho_dungen_bsp_BSPGeneratorConfig.prototype = {
	width: null
	,height: null
	,minHeight: null
	,minWidth: null
	,depth: null
	,ratio: null
	,x: null
	,y: null
	,seed: null
	,__class__: dropecho_dungen_bsp_BSPGeneratorConfig
};
var dropecho_dungen_bsp_Generator = $hx_exports["dungen"]["BSPGenerator"] = function(ops) {
	this.random = new seedyrng_Random();
	dropecho_dungen_bsp_BSPGeneratorConfig.call(this);
	dropecho_interop_Extender.extendThis(this,ops);
	this.random.setStringSeed(this.seed);
};
dropecho_dungen_bsp_Generator.__name__ = "dropecho.dungen.bsp.Generator";
dropecho_dungen_bsp_Generator.__super__ = dropecho_dungen_bsp_BSPGeneratorConfig;
dropecho_dungen_bsp_Generator.prototype = $extend(dropecho_dungen_bsp_BSPGeneratorConfig.prototype,{
	random: null
	,generate: function() {
		this.random.setStringSeed(this.seed);
		var rootData = { height : this.height, width : this.width, x : this.x, y : this.y};
		var tree = new dropecho_ds_BSPTree(rootData);
		this.buildTree(tree.getRoot());
		return tree;
	}
	,buildTree: function(node,level) {
		if(level == null) {
			level = 0;
		}
		if(node == null || level >= this.depth) {
			return;
		}
		this.makeSplit(node);
		this.buildTree(node.left,level + 1);
		this.buildTree(node.right,level + 1);
	}
	,makeSplit: function(node) {
		var val = node.value;
		var lData;
		var rData;
		if(val.width < this.minWidth * 2 && val.height < this.minHeight * 2) {
			return;
		}
		var splitAt = 0;
		var splitHeight = this.random.random() > 0.5;
		if(val.width >= val.height * this.ratio) {
			splitHeight = false;
		} else if(val.height >= val.width * this.ratio) {
			splitHeight = true;
		} else {
			return;
		}
		if(splitHeight) {
			splitAt = this.random.randomInt(0,val.height - this.minHeight * 2) + this.minHeight;
			var rHeight = val.height - splitAt;
			lData = new dropecho_dungen_bsp_BspData({ height : splitAt, width : val.width, x : val.x, y : val.y});
			rData = new dropecho_dungen_bsp_BspData({ height : rHeight, width : val.width, x : val.x, y : val.y + splitAt});
		} else {
			splitAt = this.random.randomInt(0,val.width - this.minWidth * 2) + this.minWidth;
			var rWidth = val.width - splitAt;
			lData = new dropecho_dungen_bsp_BspData({ height : val.height, width : splitAt, x : val.x, y : val.y});
			rData = new dropecho_dungen_bsp_BspData({ height : val.height, width : rWidth, x : val.x + splitAt, y : val.y});
		}
		node.setLeft(new dropecho_ds_BSPNode(lData));
		node.setRight(new dropecho_ds_BSPNode(rData));
	}
	,__class__: dropecho_dungen_bsp_Generator
});
var dropecho_dungen_export_TiledExporter = $hx_exports["dungen"]["TiledExporter"] = function() { };
dropecho_dungen_export_TiledExporter.__name__ = "dropecho.dungen.export.TiledExporter";
dropecho_dungen_export_TiledExporter.export = function(map) {
	return "0";
};
var dropecho_dungen_generators_CA_$PARAMS = $hx_exports["dungen"]["CA_PARAMS"] = function() {
	this.seed = "0";
	this.start_fill_percent = 65;
	this.tile_wall = 0;
	this.tile_floor = 1;
	this.width = 64;
	this.height = 64;
	this.steps = [];
	this.steps = [{ reps : 4, r1_cutoff : 5, r2_cutoff : 2, invert : true},{ reps : 3, r1_cutoff : 5, r2_cutoff : 0, invert : true}];
};
dropecho_dungen_generators_CA_$PARAMS.__name__ = "dropecho.dungen.generators.CA_PARAMS";
dropecho_dungen_generators_CA_$PARAMS.prototype = {
	steps: null
	,height: null
	,width: null
	,tile_floor: null
	,tile_wall: null
	,start_fill_percent: null
	,seed: null
	,__class__: dropecho_dungen_generators_CA_$PARAMS
};
var dropecho_dungen_generators_CAGenerator = $hx_exports["dungen"]["CAGenerator"] = function() { };
dropecho_dungen_generators_CAGenerator.__name__ = "dropecho.dungen.generators.CAGenerator";
dropecho_dungen_generators_CAGenerator.generate = function(opts) {
	var params = dropecho_interop_Extender.defaults(new dropecho_dungen_generators_CA_$PARAMS(),opts);
	var map = dropecho_dungen_generators_RandomGenerator.generate(params);
	var _g = 0;
	var _g1 = params.steps;
	while(_g < _g1.length) {
		var step = _g1[_g];
		++_g;
		var _g2 = 0;
		var _g3 = step.reps;
		while(_g2 < _g3) {
			var _ = _g2++;
			dropecho_dungen_generators_CAGenerator.buildFromCA(map,params,step);
		}
	}
	return map;
};
dropecho_dungen_generators_CAGenerator.buildFromCA = function(map,params,step) {
	var temp = new haxe_ds_IntMap();
	var _g = 0;
	var _g1 = params.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = params.height;
		while(_g2 < _g3) {
			var y = _g2++;
			var tile_to_count = step.invert ? params.tile_floor : params.tile_wall;
			var nCount = map.getNeighborCount(x,y,tile_to_count);
			var nCount2 = map.getNeighborCount(x,y,tile_to_count,2);
			var pos = map._width * y + x;
			if(nCount >= step.r1_cutoff || nCount2 <= step.r2_cutoff) {
				temp.h[pos] = params.tile_wall;
			} else {
				temp.h[pos] = params.tile_floor;
			}
		}
	}
	var i = temp.keys();
	while(i.hasNext()) {
		var i1 = i.next();
		var pos = map.IndexToXY(i1);
		map._mapData[map._width * pos.y + pos.x] = temp.h[i1];
	}
};
var dropecho_dungen_generators_ConvChain = $hx_exports["dungen"]["ConvChain"] = function(sample) {
	this.seed = "0";
	this.sample = sample;
	this.cachedN = -1;
	this.cachedWeights = null;
	this.rng = new seedyrng_Random();
	this.rng.setStringSeed(this.seed);
};
dropecho_dungen_generators_ConvChain.__name__ = "dropecho.dungen.generators.ConvChain";
dropecho_dungen_generators_ConvChain.prototype = {
	sample: null
	,cachedN: null
	,cachedWeights: null
	,rng: null
	,seed: null
	,processWeights: function(sample,n) {
		var size = Math.pow(2,n * n) | 0;
		var _g = [];
		var _g1 = 0;
		var _g2 = size;
		while(_g1 < _g2) {
			var _ = _g1++;
			_g.push(0.0);
		}
		var weights = _g;
		var _g = 0;
		var _g1 = sample._height;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = sample._width;
			while(_g2 < _g3) {
				var y = _g2++;
				var rect = sample.getRect(x,y,x + n - 1,y + n - 1,true);
				var p = dropecho_dungen_map_Pattern.init(n,rect);
				var _g4 = 0;
				var _g5 = p.hashes.length;
				while(_g4 < _g5) {
					var h = _g4++;
					weights[p.hashes[h]] += 1;
				}
			}
		}
		var _g = 0;
		var _g1 = weights.length;
		while(_g < _g1) {
			var k = _g++;
			weights[k] = weights[k] <= 0 ? 0.1 : weights[k];
		}
		return weights;
	}
	,getWeights: function(n) {
		if(this.cachedN != n) {
			this.cachedN = n;
			this.cachedWeights = this.processWeights(this.sample,n);
		}
		return this.cachedWeights;
	}
	,generateBaseField: function(width,height) {
		return dropecho_dungen_generators_RandomGenerator.generate({ height : height, width : width, seed : this.seed});
	}
	,applyChanges: function(field,weights,n,temperature,changes) {
		var r;
		var q;
		var x;
		var y;
		var ind;
		var difference;
		var _g = 0;
		var _g1 = changes;
		while(_g < _g1) {
			var _ = _g++;
			q = 1.0;
			r = this.rng.randomInt(0,field._mapData.length);
			x = r % field._width | 0;
			y = r / field._width | 0;
			var _g2 = y - n + 1;
			var _g3 = y + n;
			while(_g2 < _g3) {
				var sy = _g2++;
				var _g4 = x - n + 1;
				var _g5 = x + n;
				while(_g4 < _g5) {
					var sx = _g4++;
					ind = 0;
					difference = 0;
					var _g6 = 0;
					var _g7 = n;
					while(_g6 < _g7) {
						var dy = _g6++;
						var _g8 = 0;
						var _g9 = n;
						while(_g8 < _g9) {
							var dx = _g8++;
							var power = 1 << dy * n + dx;
							var X = sx + dx;
							var Y = sy + dy;
							X = Math.abs(X % field._width) | 0;
							Y = Math.abs(Y % field._height) | 0;
							var value = field._mapData[field._width * Y + X];
							ind += value != 0 ? power : 0;
							if(X == x && Y == y) {
								difference = value != 0 ? power : -power;
							}
						}
					}
					var a = weights[ind - difference];
					var b = weights[ind];
					q *= a / b;
				}
			}
			if(q >= 1) {
				field._mapData[field._width * y + x] = field._mapData[field._width * y + x] != 1 ? 1 : 0;
			} else {
				if(temperature != 1) {
					q = Math.pow(q,1.0 / temperature);
				}
				if(q > this.rng.random()) {
					field._mapData[field._width * y + x] = field._mapData[field._width * y + x] != 1 ? 1 : 0;
				}
			}
		}
	}
	,generate: function(width,height,n,temperature,iterations) {
		var changesPerIterations = width * height;
		var field = this.generateBaseField(width,height);
		var weights = this.getWeights(n);
		var _g = 0;
		var _g1 = iterations;
		while(_g < _g1) {
			var _ = _g++;
			this.applyChanges(field,weights,n,temperature,changesPerIterations);
		}
		return field;
	}
	,__class__: dropecho_dungen_generators_ConvChain
};
var dropecho_dungen_generators_FloorPlanGenerator = $hx_exports["dungen"]["FloorPlanGenerator"] = function() { };
dropecho_dungen_generators_FloorPlanGenerator.__name__ = "dropecho.dungen.generators.FloorPlanGenerator";
dropecho_dungen_generators_FloorPlanGenerator.generate = function(params) {
	var width = params.width;
	var height = params.height;
	var tile_floor = params.tile_floor;
	var tile_wall = params.tile_wall;
	var map = new dropecho_dungen_Map2d(width,height);
	var rooms = [];
	rooms.push({ width : 20, height : 20, x : -999999, y : -999999});
	rooms.push({ width : 20, height : 20, x : -999999, y : -999999});
	rooms.push({ width : 20, height : 30, x : -999999, y : -999999});
	rooms.push({ width : 30, height : 20, x : -999999, y : -999999});
	dropecho_dungen_generators_FloorPlanGenerator.arrangeRooms(map,rooms);
	return map;
};
dropecho_dungen_generators_FloorPlanGenerator.scaleFloorPlan = function(map,rooms) {
};
dropecho_dungen_generators_FloorPlanGenerator.arrangeRooms = function(map,rooms) {
	var random = new seedyrng_Random();
	var mapMidX = map._width / 2;
	var mapMidY = map._height / 2;
	var randomRooms = rooms.slice();
	random.shuffle(randomRooms);
	var _g = 0;
	while(_g < randomRooms.length) {
		var r = randomRooms[_g];
		++_g;
		r.x = 500;
		r.y = 500;
		var isRight = r.x > mapMidX;
		var isAbove = r.y > mapMidY;
	}
};
var dropecho_dungen_generators_MixedGenerator = $hx_exports["dungen"]["MixedGenerator"] = function() { };
dropecho_dungen_generators_MixedGenerator.__name__ = "dropecho.dungen.generators.MixedGenerator";
dropecho_dungen_generators_MixedGenerator.buildRooms = function(tree,opts) {
	var random = new seedyrng_Random();
	var params = dropecho_interop_Extender.defaults({ tile_wall : 0, tile_floor : 1, cave_percent : 20, seed : "0"},opts);
	random.setStringSeed(params.seed);
	var rootvalue = tree.root.value;
	var map = new dropecho_dungen_Map2d(rootvalue.width,rootvalue.height,params.tile_wall);
	var makeRooms = function(node) {
		if(node.hasLeft() || node.hasRight()) {
			return true;
		}
		var roomStartX = node.value.x + 1;
		var roomStartY = node.value.y + 1;
		var roomEndX = node.value.x + node.value.width - 1;
		var roomEndY = node.value.y + node.value.height - 1;
		var _g = roomStartX;
		var _g1 = roomEndX;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = roomStartY;
			var _g3 = roomEndY;
			while(_g2 < _g3) {
				var y = _g2++;
				map._mapData[map._width * y + x] = params.tile_floor;
			}
		}
		return true;
	};
	var makeCaveFromCA = function(node) {
		if((node.hasLeft() || node.hasRight()) && (node.right.hasRight() || node.right.hasLeft() || node.left.hasRight() || node.left.hasLeft())) {
			return true;
		}
		var roomStartX = node.value.x + 1;
		var roomStartY = node.value.y + 1;
		var cave = dropecho_dungen_generators_CAGenerator.generate({ height : node.value.height, width : node.value.width});
		var _g = 0;
		var _g1 = cave._width;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = cave._height;
			while(_g2 < _g3) {
				var y = _g2++;
				map._mapData[map._width * (y + roomStartY) + (x + roomStartX)] = cave._mapData[cave._width * y + x];
			}
		}
		return true;
	};
	var makeCorridors = function(node) {
		if(!node.hasLeft() && !node.hasRight()) {
			return true;
		}
		var leftXcenter = node.left.value.x + node.left.value.width / 2 | 0;
		var leftYcenter = node.left.value.y + node.left.value.height / 2 | 0;
		var rightXcenter = node.right.value.x + node.right.value.width / 2 | 0;
		var rightYcenter = node.right.value.y + node.right.value.height / 2 | 0;
		var startX = leftXcenter <= rightXcenter ? leftXcenter : rightXcenter;
		var endX = leftXcenter >= rightXcenter ? leftXcenter : rightXcenter;
		var startY = leftYcenter <= rightYcenter ? leftYcenter : rightYcenter;
		var endY = leftYcenter >= rightYcenter ? leftYcenter : rightYcenter;
		var _g = startX;
		var _g1 = endX;
		while(_g < _g1) {
			var x = _g++;
			map._mapData[map._width * startY + x] = params.tile_floor;
		}
		var _g = startY;
		var _g1 = endY;
		while(_g < _g1) {
			var y = _g++;
			map._mapData[map._width * y + startX] = params.tile_floor;
		}
		return true;
	};
	var chooseRoomOrCave = function(node) {
		if(random.random() * 100 > params.cave_percent) {
			return makeRooms(node);
		} else {
			return makeCaveFromCA(node);
		}
	};
	var closeEdges = function(node) {
		if(!node.isRoot()) {
			return true;
		}
		var _g = 0;
		var _g1 = node.value.width;
		while(_g < _g1) {
			var x = _g++;
			map._mapData[map._width * 0 + x] = params.tile_wall;
			map._mapData[map._width * node.value.height + x] = params.tile_wall;
		}
		var _g = 0;
		var _g1 = node.value.height;
		while(_g < _g1) {
			var y = _g++;
			map._mapData[map._width * y] = params.tile_wall;
			map._mapData[map._width * y + node.value.width] = params.tile_wall;
		}
		return false;
	};
	var povisitor = new dropecho_ds_algos_PostOrderTraversal();
	var invisitor = new dropecho_ds_algos_InOrderTraversal();
	povisitor.run(tree.root,chooseRoomOrCave);
	povisitor.visited.length = 0;
	invisitor.run(tree.root,closeEdges);
	povisitor.run(tree.root,makeCorridors);
	return map;
};
var dropecho_dungen_generators_RandomParams = function() {
	this.seed = "0";
	this.start_fill_percent = 50;
	this.tile_wall = 0;
	this.tile_floor = 1;
	this.width = 64;
	this.height = 64;
};
dropecho_dungen_generators_RandomParams.__name__ = "dropecho.dungen.generators.RandomParams";
dropecho_dungen_generators_RandomParams.prototype = {
	height: null
	,width: null
	,tile_floor: null
	,tile_wall: null
	,start_fill_percent: null
	,seed: null
	,__class__: dropecho_dungen_generators_RandomParams
};
var dropecho_dungen_generators_RandomGenerator = $hx_exports["dungen"]["RandomGenerator"] = function() { };
dropecho_dungen_generators_RandomGenerator.__name__ = "dropecho.dungen.generators.RandomGenerator";
dropecho_dungen_generators_RandomGenerator.generate = function(opts) {
	var params = dropecho_interop_Extender.defaults(new dropecho_dungen_generators_RandomParams(),opts);
	var random = new seedyrng_Random();
	random.setStringSeed(params.seed);
	var map = new dropecho_dungen_Map2d(params.width,params.height,params.tile_wall);
	var _g = 0;
	var _g1 = params.width * params.height;
	while(_g < _g1) {
		var i = _g++;
		map._mapData[i] = random.random() * 100 > params.start_fill_percent ? params.tile_floor : params.tile_wall;
	}
	return map;
};
var dropecho_dungen_generators_RoomParams = function() {
	this.padding = 0;
	this.tileWall = 0;
	this.tileFloor = 1;
};
dropecho_dungen_generators_RoomParams.__name__ = "dropecho.dungen.generators.RoomParams";
dropecho_dungen_generators_RoomParams.prototype = {
	tileFloor: null
	,tileWall: null
	,padding: null
	,__class__: dropecho_dungen_generators_RoomParams
};
var dropecho_dungen_generators_RoomGenerator = $hx_exports["dungen"]["RoomGenerator"] = function() { };
dropecho_dungen_generators_RoomGenerator.__name__ = "dropecho.dungen.generators.RoomGenerator";
dropecho_dungen_generators_RoomGenerator.buildRooms = function(tree,opts) {
	var params = dropecho_interop_Extender.defaults(new dropecho_dungen_generators_RoomParams(),opts);
	var rootvalue = tree.getRoot().value;
	var map = new dropecho_dungen_Map2d(rootvalue.width,rootvalue.height,params.tileWall);
	var makeRoom = function(node) {
		if(node.hasLeft() || node.hasRight()) {
			return true;
		}
		var lPad = params.padding / 2 | 0;
		var rPad = (params.padding / 2 | 0) + params.padding % 2;
		var roomStartX = node.value.x + 1 + lPad;
		var roomStartY = node.value.y + 1 + lPad;
		var roomEndX = node.value.x + node.value.width - 1 - rPad;
		var roomEndY = node.value.y + node.value.height - 1 - rPad;
		if(roomStartX != 1) {
			--roomStartX;
		}
		if(roomStartY != 1) {
			--roomStartY;
		}
		var _g = roomStartX;
		var _g1 = roomEndX;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = roomStartY;
			var _g3 = roomEndY;
			while(_g2 < _g3) {
				var y = _g2++;
				map._mapData[map._width * y + x] = params.tileFloor;
			}
		}
		return true;
	};
	var makeCorridors = function(node) {
		if(!node.hasLeft() && !node.hasRight()) {
			return true;
		}
		var leftXcenter = node.left.value.x + node.left.value.width / 2 | 0;
		var leftYcenter = node.left.value.y + node.left.value.height / 2 | 0;
		var rightXcenter = node.right.value.x + node.right.value.width / 2 | 0;
		var rightYcenter = node.right.value.y + node.right.value.height / 2 | 0;
		var startX = leftXcenter <= rightXcenter ? leftXcenter : rightXcenter;
		var endX = leftXcenter >= rightXcenter ? leftXcenter : rightXcenter;
		var startY = leftYcenter <= rightYcenter ? leftYcenter : rightYcenter;
		var endY = leftYcenter >= rightYcenter ? leftYcenter : rightYcenter;
		var _g = startX;
		var _g1 = endX;
		while(_g < _g1) {
			var x = _g++;
			map._mapData[map._width * startY + x] = params.tileFloor;
		}
		var _g = startY;
		var _g1 = endY;
		while(_g < _g1) {
			var y = _g++;
			map._mapData[map._width * y + startX] = params.tileFloor;
		}
		return true;
	};
	var visitor = new dropecho_ds_algos_PostOrderTraversal();
	visitor.run(tree.root,makeRoom);
	visitor.visited.length = 0;
	visitor.run(tree.root,makeCorridors);
	return map;
};
var dropecho_dungen_generators_TunnelerGenerator = $hx_exports["dungen"]["TunnelerGenerator"] = function() { };
dropecho_dungen_generators_TunnelerGenerator.__name__ = "dropecho.dungen.generators.TunnelerGenerator";
dropecho_dungen_generators_TunnelerGenerator.generate = function(params) {
	var height = params.height;
	var width = params.width;
	var tile_floor = params.tile_floor;
	var tile_wall = params.tile_wall;
	var start_fill_percent = params.start_fill_percent;
	var countOfFilled = 0;
	var totalCount = height * width;
	var map = new dropecho_dungen_Map2d(width,height,tile_wall);
	var walkerPos_x = width / 2 | 0;
	var walkerPos_y = height / 2 | 0;
	map._mapData[map._width * walkerPos_y + walkerPos_x] = 0;
	return map;
};
dropecho_dungen_generators_TunnelerGenerator.getEntrancePosition = function(map) {
	var random = new seedyrng_Random();
	var top = random.randomInt(0,1) == 1;
	var right = random.randomInt(0,1) == 1;
	return null;
};
var dropecho_dungen_generators__$TunnelerGenerator_Tunneler = function(map,position,width,direction,lifeSpan) {
	if(lifeSpan == null) {
		lifeSpan = 5;
	}
	if(direction == null) {
		direction = 2;
	}
	if(width == null) {
		width = 1;
	}
	this.map = map;
	this.position = position;
	this.width = width;
	this.direction = direction;
	this.lifeSpan = lifeSpan;
};
dropecho_dungen_generators__$TunnelerGenerator_Tunneler.__name__ = "dropecho.dungen.generators._TunnelerGenerator.Tunneler";
dropecho_dungen_generators__$TunnelerGenerator_Tunneler.prototype = {
	map: null
	,position: null
	,width: null
	,direction: null
	,lifeSpan: null
	,run: function() {
		var ticks = 0;
		while(ticks < this.lifeSpan) {
		}
	}
	,__class__: dropecho_dungen_generators__$TunnelerGenerator_Tunneler
};
var dropecho_dungen_generators_WALK_$PARAMS_$DEF = function() {
	this.seed = "0";
	this.start_fill_percent = 50;
	this.tile_wall = 0;
	this.tile_floor = 1;
	this.width = 64;
	this.height = 64;
};
dropecho_dungen_generators_WALK_$PARAMS_$DEF.__name__ = "dropecho.dungen.generators.WALK_PARAMS_DEF";
dropecho_dungen_generators_WALK_$PARAMS_$DEF.prototype = {
	height: null
	,width: null
	,tile_floor: null
	,tile_wall: null
	,start_fill_percent: null
	,seed: null
	,__class__: dropecho_dungen_generators_WALK_$PARAMS_$DEF
};
var dropecho_dungen_generators_WalkGenerator = $hx_exports["dungen"]["WalkGenerator"] = function() { };
dropecho_dungen_generators_WalkGenerator.__name__ = "dropecho.dungen.generators.WalkGenerator";
dropecho_dungen_generators_WalkGenerator.generate = function(opts) {
	var params = dropecho_interop_Extender.defaults(new dropecho_dungen_generators_WALK_$PARAMS_$DEF(),opts);
	var random = new seedyrng_Random();
	random.setStringSeed(params.seed);
	var countOfFilled = 0;
	var totalCount = params.height * params.width;
	var map = new dropecho_dungen_Map2d(params.width,params.height,params.tile_wall);
	var walkerPos_x = params.width / 2 | 0;
	var walkerPos_y = params.height / 2 | 0;
	map._mapData[map._width * walkerPos_y + walkerPos_x] = 0;
	var counter = 0;
	var direction = random.randomInt(0,3);
	while(countOfFilled < totalCount * (params.start_fill_percent / 100)) {
		direction = random.randomInt(0,3);
		if(map._mapData[map._width * walkerPos_y + walkerPos_x] != params.tile_floor) {
			map._mapData[map._width * walkerPos_y + walkerPos_x] = params.tile_floor;
			++countOfFilled;
		}
		walkerPos_y += direction == 0 ? -1 : 0;
		walkerPos_y += direction == 2 ? 1 : 0;
		walkerPos_x += direction == 1 ? -1 : 0;
		walkerPos_x += direction == 3 ? 1 : 0;
		if(walkerPos_x < 0 || walkerPos_x > params.width - 1) {
			walkerPos_x = params.width / 2 | 0;
			walkerPos_y = params.height / 2 | 0;
		}
		if(walkerPos_y < 0 || walkerPos_y > params.height - 1) {
			walkerPos_x = params.width / 2 | 0;
			walkerPos_y = params.height / 2 | 0;
		}
		if(counter >= 500000) {
			break;
		}
		++counter;
	}
	return map;
};
var dropecho_dungen_map_Pattern = $hx_exports["dungen"]["Pattern"] = function(size,initTileData) {
	if(initTileData == null) {
		initTileData = 0;
	}
	this.hashes = [];
	this.patterns = [];
	dropecho_dungen_Map2d.call(this,size,size,initTileData);
};
dropecho_dungen_map_Pattern.__name__ = "dropecho.dungen.map.Pattern";
dropecho_dungen_map_Pattern.init = function(size,pattern,symmetry) {
	if(symmetry == null) {
		symmetry = 255;
	}
	var p = new dropecho_dungen_map_Pattern(size,0);
	p._mapData = pattern;
	p.buildVariations(symmetry);
	return p;
};
dropecho_dungen_map_Pattern.__super__ = dropecho_dungen_Map2d;
dropecho_dungen_map_Pattern.prototype = $extend(dropecho_dungen_Map2d.prototype,{
	patterns: null
	,hashes: null
	,matchesIndex: function(map,x,y,tileToIgnore) {
		if(tileToIgnore == null) {
			tileToIgnore = -1;
		}
		var toMatch = map.getRect(x,y,x + this._width - 1,y + this._height - 1);
		var match = false;
		var _g = 0;
		var _g1 = this.patterns.length;
		while(_g < _g1) {
			var p = _g++;
			var pattern = this.patterns[p];
			var _g2 = 0;
			var _g3 = pattern.length;
			while(_g2 < _g3) {
				var tile = _g2++;
				match = toMatch[tile] == pattern[tile] || pattern[tile] == tileToIgnore;
				if(!match) {
					break;
				}
			}
			if(match) {
				return p;
			}
		}
		return -1;
	}
	,matches: function(map,x,y) {
		return this.matchesIndex(map,x,y) != -1;
	}
	,buildVariations: function(symmetry) {
		if(symmetry == null) {
			symmetry = 255;
		}
		var n = this._width;
		var variations = [];
		variations[0] = this._mapData;
		var p = variations[0];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - y + x * n]);
			}
		}
		variations[1] = _g;
		var p = variations[1];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - y + x * n]);
			}
		}
		variations[2] = _g;
		var p = variations[2];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - y + x * n]);
			}
		}
		variations[3] = _g;
		var p = variations[0];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - x + y * n]);
			}
		}
		variations[4] = _g;
		var p = variations[1];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - x + y * n]);
			}
		}
		variations[5] = _g;
		var p = variations[2];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - x + y * n]);
			}
		}
		variations[6] = _g;
		var p = variations[3];
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = n;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(p[n - 1 - x + y * n]);
			}
		}
		variations[7] = _g;
		var tmp = this.hashes;
		var p = variations[0];
		var result = 0;
		var power = 1;
		var _g = 0;
		var _g1 = p.length;
		while(_g < _g1) {
			var i = _g++;
			result += p[p.length - 1 - i] != 0 ? power : 0;
			power *= 2;
		}
		tmp[0] = result;
		this.patterns[0] = variations[0];
		if((symmetry & 1) != 0) {
			var tmp = this.hashes;
			var p = variations[1];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[1] = result;
			this.patterns[1] = variations[1];
		}
		if((symmetry & 2) != 0) {
			var tmp = this.hashes;
			var p = variations[2];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[2] = result;
			this.patterns[2] = variations[2];
		}
		if((symmetry & 3) != 0) {
			var tmp = this.hashes;
			var p = variations[3];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[3] = result;
			this.patterns[3] = variations[3];
		}
		if((symmetry & 4) != 0) {
			var tmp = this.hashes;
			var p = variations[4];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[4] = result;
			this.patterns[4] = variations[4];
		}
		if((symmetry & 5) != 0) {
			var tmp = this.hashes;
			var p = variations[5];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[5] = result;
			this.patterns[5] = variations[5];
		}
		if((symmetry & 6) != 0) {
			var tmp = this.hashes;
			var p = variations[6];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[6] = result;
			this.patterns[6] = variations[6];
		}
		if((symmetry & 7) != 0) {
			var tmp = this.hashes;
			var p = variations[7];
			var result = 0;
			var power = 1;
			var _g = 0;
			var _g1 = p.length;
			while(_g < _g1) {
				var i = _g++;
				result += p[p.length - 1 - i] != 0 ? power : 0;
				power *= 2;
			}
			tmp[7] = result;
			this.patterns[7] = variations[7];
		}
	}
	,__class__: dropecho_dungen_map_Pattern
});
var dropecho_dungen_map_helpers_CheckConnectivity = $hx_exports["dungen"]["CheckConnectivity"] = function() { };
dropecho_dungen_map_helpers_CheckConnectivity.__name__ = "dropecho.dungen.map.helpers.CheckConnectivity";
dropecho_dungen_map_helpers_CheckConnectivity.checkConnectivity = function(map,tile,diagonal) {
	if(diagonal == null) {
		diagonal = true;
	}
	if(tile == null) {
		tile = 0;
	}
	var firstTile = dropecho_dungen_map_helpers_GetFirstTileOfType.getFirstTileOfType(map,tile);
	if(firstTile == null) {
		return false;
	}
	var filledTiles = dropecho_dungen_map_helpers_FloodFill.floodFill(map,firstTile.x,firstTile.y,tile,diagonal);
	firstTile = dropecho_dungen_map_helpers_GetFirstTileOfType.getFirstTileOfType(map,tile,filledTiles);
	return firstTile == null;
};
var dropecho_dungen_map_helpers_DistanceFill = $hx_exports["dungen"]["DistanceFill"] = function() { };
dropecho_dungen_map_helpers_DistanceFill.__name__ = "dropecho.dungen.map.helpers.DistanceFill";
dropecho_dungen_map_helpers_DistanceFill.distanceFill = function(map,tile,diagonal,maxDepth) {
	if(maxDepth == null) {
		maxDepth = 40;
	}
	if(diagonal == null) {
		diagonal = true;
	}
	if(tile == null) {
		tile = 0;
	}
	var distanceMap = new dropecho_dungen_Map2d(map._width,map._height);
	var _g = 0;
	var _g1 = map._mapData.length;
	while(_g < _g1) {
		var i = _g++;
		distanceMap._mapData[i] = map._mapData[i] == tile ? 0 : 999;
	}
	var pass = 0;
	var changes = 1;
	while(changes > 0 && pass++ < maxDepth) {
		changes = 0;
		var _g = 0;
		var _g1 = distanceMap._width;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g3 = distanceMap._height;
			while(_g2 < _g3) {
				var y = _g2++;
				var neighbors = distanceMap.getNeighbors(x,y,1);
				var _g4 = 0;
				while(_g4 < neighbors.length) {
					var n = neighbors[_g4];
					++_g4;
					var v = distanceMap._mapData[distanceMap._width * y + x];
					var nval = distanceMap._mapData[distanceMap._width * n.y + n.x];
					if(nval < v) {
						distanceMap._mapData[distanceMap._width * y + x] = nval + 1;
						++changes;
					}
				}
			}
		}
	}
	return distanceMap;
};
var dropecho_dungen_map_helpers_FindAndReplace = $hx_exports["dungen"]["FindAndReplace"] = function() { };
dropecho_dungen_map_helpers_FindAndReplace.__name__ = "dropecho.dungen.map.helpers.FindAndReplace";
dropecho_dungen_map_helpers_FindAndReplace.findAndReplace = function(map,pattern1,pattern2,ignoreTile) {
	if(ignoreTile == null) {
		ignoreTile = -1;
	}
	var _g = 0;
	var _g1 = map._width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = map._height;
		while(_g2 < _g3) {
			var y = _g2++;
			var matchesIndex = pattern1.matchesIndex(map,x,y);
			if(matchesIndex != -1) {
				var m = new dropecho_dungen_Map2d(pattern1._width,pattern1._height);
				m._mapData = pattern1.patterns[matchesIndex];
				var splat = new dropecho_dungen_Map2d(pattern2._width,pattern2._height);
				splat._mapData = pattern2.patterns[matchesIndex];
				map.splat(splat,x,y,ignoreTile);
			}
		}
	}
	return map;
};
var dropecho_dungen_map_helpers_FloodFill = $hx_exports["dungen"]["FloodFill"] = function() { };
dropecho_dungen_map_helpers_FloodFill.__name__ = "dropecho.dungen.map.helpers.FloodFill";
dropecho_dungen_map_helpers_FloodFill.floodFill = function(map,startX,startY,tile,diagonal) {
	if(diagonal == null) {
		diagonal = true;
	}
	if(tile == null) {
		tile = 0;
	}
	var closed = new haxe_ds_IntMap();
	var open = [];
	var neighbors = [];
	var currentTile = map.IndexToXY(map._width * startY + startX);
	open.push(currentTile);
	var whereHasNotBeenVisited = function(tile) {
		return closed.h[map._width * tile.y + tile.x] == null;
	};
	var whereTileIsSameType = function(t) {
		return map._mapData[map._width * t.y + t.x] == tile;
	};
	while(open.length > 0) {
		currentTile = open.pop();
		closed.h[map._width * currentTile.y + currentTile.x] = currentTile;
		var _g = [];
		var _g1 = 0;
		var _g2 = map.getNeighbors(currentTile.x,currentTile.y,1,diagonal);
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(whereHasNotBeenVisited(v)) {
				_g.push(v);
			}
		}
		var _g3 = [];
		var _g4 = 0;
		var _g5 = _g;
		while(_g4 < _g5.length) {
			var v1 = _g5[_g4];
			++_g4;
			if(whereTileIsSameType(v1)) {
				_g3.push(v1);
			}
		}
		neighbors = _g3;
		open = open.concat(neighbors);
	}
	return Lambda.array(closed);
};
var dropecho_dungen_map_helpers_GetFirstTileOfType = $hx_exports["dungen"]["GetFirstTileOfType"] = function() { };
dropecho_dungen_map_helpers_GetFirstTileOfType.__name__ = "dropecho.dungen.map.helpers.GetFirstTileOfType";
dropecho_dungen_map_helpers_GetFirstTileOfType.getFirstTileOfType = function(map,tile,ignore) {
	if(tile == null) {
		tile = 0;
	}
	var _g = 0;
	var _g1 = map._height * map._width;
	while(_g < _g1) {
		var i = _g++;
		if(map._mapData[i] == tile) {
			var cur = [map.IndexToXY(i)];
			if(ignore != null) {
				var foo = Lambda.find(ignore,(function(cur) {
					return function(tile) {
						if(tile.x == cur[0].x) {
							return tile.y == cur[0].y;
						} else {
							return false;
						}
					};
				})(cur));
				if(foo != null) {
					continue;
				}
			}
			return cur[0];
		}
	}
	return null;
};
var dropecho_dungen_map_helpers_RegionManager = $hx_exports["dungen"]["RegionManager"] = function() { };
dropecho_dungen_map_helpers_RegionManager.__name__ = "dropecho.dungen.map.helpers.RegionManager";
dropecho_dungen_map_helpers_RegionManager.findAndTagRegions = function(map,depth) {
	if(depth == null) {
		depth = 2;
	}
	var regionmap = new dropecho_dungen_Map2d(map._width,map._height,0);
	var _g = 0;
	var _g1 = map._mapData.length;
	while(_g < _g1) {
		var i = _g++;
		var val = map._mapData[i] > depth ? depth : map._mapData[i];
		regionmap._mapData[i] = val;
	}
	var nextRegion;
	var nextTag = depth + 1;
	while(true) {
		nextRegion = dropecho_dungen_map_helpers_GetFirstTileOfType.getFirstTileOfType(regionmap,depth);
		if(!(nextRegion != null)) {
			break;
		}
		var tilesToFill = dropecho_dungen_map_helpers_FloodFill.floodFill(regionmap,nextRegion.x,nextRegion.y,depth);
		var _g = 0;
		while(_g < tilesToFill.length) {
			var t = tilesToFill[_g];
			++_g;
			regionmap._mapData[regionmap._width * t.y + t.x] = nextTag;
		}
		if(tilesToFill.length == 1) {
			regionmap._mapData[regionmap._width * nextRegion.y + nextRegion.x] = 1;
		}
		++nextTag;
	}
	return regionmap;
};
dropecho_dungen_map_helpers_RegionManager.expandRegions = function(map,startTag,eatWalls) {
	if(eatWalls == null) {
		eatWalls = false;
	}
	if(startTag == null) {
		startTag = 3;
	}
	var _g = 0;
	while(_g < 100) {
		var _ = _g++;
		var _g1 = startTag;
		var _g2 = startTag + 500;
		while(_g1 < _g2) {
			var currentTag = _g1++;
			var tilesToPaint = [];
			var _g3 = 0;
			var _g4 = map._width;
			while(_g3 < _g4) {
				var x = _g3++;
				var _g5 = 0;
				var _g6 = map._height;
				while(_g5 < _g6) {
					var y = _g5++;
					if(map._mapData[map._width * y + x] == currentTag) {
						var neighbors = map.getNeighbors(x,y,1,true);
						var _g7 = 0;
						while(_g7 < neighbors.length) {
							var n = neighbors[_g7];
							++_g7;
							if(n.val < startTag) {
								if(!eatWalls && n.val == 0) {
									continue;
								}
								var nWalls = map.getNeighborCount(n.x,n.y,0,1,true);
								var nOpen = 0;
								var _g8 = 1;
								var _g9 = startTag;
								while(_g8 < _g9) {
									var i = _g8++;
									nOpen += map.getNeighborCount(n.x,n.y,i,1,true);
								}
								var nTag = map.getNeighborCount(n.x,n.y,currentTag,1,true);
								if(nWalls + nOpen + nTag == 8) {
									tilesToPaint.push(map._width * n.y + n.x);
								}
							}
						}
					}
				}
			}
			var _g10 = 0;
			while(_g10 < tilesToPaint.length) {
				var c = tilesToPaint[_g10];
				++_g10;
				map._mapData[c] = currentTag;
			}
		}
	}
	return map;
};
var dropecho_dungen_map_helpers_Utils = function() { };
dropecho_dungen_map_helpers_Utils.__name__ = "dropecho.dungen.map.helpers.Utils";
dropecho_dungen_map_helpers_Utils.checkOverlap = function(r1,r2) {
	var r1p1_x = r1.x;
	var r1p1_y = r1.y;
	var r1p2_x = r1.x + r1.width;
	var r1p2_y = r1.y + r1.height;
	var r2p1_x = r2.x;
	var r2p1_y = r2.y;
	var r2p2_x = r2.x + r2.width;
	var r2p2_y = r2.y + r2.height;
	return !(r1p1_x > r2p2_x || r2p1_x > r1p2_x || r1p1_y > r2p2_y || r2p1_y > r1p2_y);
};
dropecho_dungen_map_helpers_Utils.contains = function(r1,r2) {
	var r1p1_x = r1.x;
	var r1p1_y = r1.y;
	var r1p2_x = r1.x + r1.width;
	var r1p2_y = r1.y + r1.height;
	var r2p1_x = r2.x;
	var r2p1_y = r2.y;
	var r2p2_x = r2.x + r2.width;
	var r2p2_y = r2.y + r2.height;
	if(r2p2_x < r1p2_x && r2p2_y < r1p2_y && r2p1_x > r1p1_x) {
		return r2p1_y > r1p1_y;
	} else {
		return false;
	}
};
dropecho_dungen_map_helpers_Utils.isOverlappingArray = function(r1,a) {
	var _g = 0;
	while(_g < a.length) {
		var r = a[_g];
		++_g;
		if(r == r1) {
			continue;
		}
		if(dropecho_dungen_map_helpers_Utils.checkOverlap(r1,r)) {
			return true;
		}
	}
	return false;
};
var dropecho_interop_AbstractArray = {};
dropecho_interop_AbstractArray._new = function(a) {
	var this1;
	if(a != null) {
		this1 = a;
	} else {
		this1 = [];
	}
	return this1;
};
dropecho_interop_AbstractArray.fromAny = function(d) {
	var arr = js_Boot.__cast(d , Array);
	var _g = [];
	var _g1 = 0;
	while(_g1 < arr.length) {
		var v = arr[_g1];
		++_g1;
		_g.push(v);
	}
	return dropecho_interop_AbstractArray._new(_g);
};
var dropecho_interop_AbstractMap = {};
dropecho_interop_AbstractMap._new = function(s) {
	var this1 = s;
	return this1;
};
dropecho_interop_AbstractMap.jsMap = function(d) {
	var map = new haxe_ds_StringMap();
	d.forEach(function(v,k,m) {
		map.h[k] = v;
	});
	return dropecho_interop_AbstractMap._new(map);
};
dropecho_interop_AbstractMap.fromAny = function(d) {
	if(dropecho_interop_AbstractMap.isJsMap(d)) {
		return dropecho_interop_AbstractMap.jsMap(d);
	}
	var fields = Reflect.fields(d);
	var _g = new haxe_ds_StringMap();
	var _g1 = 0;
	while(_g1 < fields.length) {
		var f = fields[_g1];
		++_g1;
		_g.h[f] = Reflect.field(d,f);
	}
	var map = _g;
	return dropecho_interop_AbstractMap._new(map);
};
dropecho_interop_AbstractMap.isJsMap = function(value) {
	return ((value) instanceof Map);
};
var dropecho_interop_Extender = $hx_exports["Extender"] = function() { };
dropecho_interop_Extender.__name__ = "dropecho.interop.Extender";
dropecho_interop_Extender.extendThis = function(base,extension) {
	if(extension == null) {
		return;
	}
	var _g = 0;
	var _g1 = Reflect.fields(base);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		var def = Reflect.field(base,f);
		var opt = Reflect.field(extension,f);
		base[f] = opt != null ? opt : def;
	}
};
dropecho_interop_Extender.defaults = function(base,extension) {
	if(base == null) {
		throw haxe_Exception.thrown("Base cannot be null.");
	}
	if(extension == null) {
		return base;
	}
	var extensions = [];
	if(((extension) instanceof Array)) {
		extensions = extension.filter(function(x) {
			return x != null;
		});
	} else {
		extensions.push(extension);
	}
	var _g = 0;
	while(_g < extensions.length) {
		var ex = extensions[_g];
		++_g;
		var fields = Reflect.fields(ex);
		var exType = js_Boot.getClass(ex);
		var typeFields;
		if(exType != null) {
			var _this = Type.getInstanceFields(exType);
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var f = _this[i];
				var typeFields1;
				if(StringTools.startsWith(f,"get_") || StringTools.startsWith(f,"set_")) {
					var parts = f.split("_");
					parts.shift();
					typeFields1 = parts.join("_");
				} else {
					typeFields1 = f;
				}
				result[i] = typeFields1;
			}
			typeFields = result;
		} else {
			typeFields = [];
		}
		if(fields.length == 0) {
			fields = typeFields;
		}
		var baseFields = [];
		var baseClass = js_Boot.getClass(base);
		if(baseClass != null) {
			baseFields = Type.getInstanceFields(baseClass);
		}
		var _g3 = 0;
		while(_g3 < fields.length) {
			var ff = fields[_g3];
			++_g3;
			var exField = Reflect.field(ex,ff);
			var baseField = Reflect.field(base,ff);
			var bfIsArray = dropecho_interop_Extender.isArray(baseField);
			var bfIsMap = dropecho_interop_Extender.isMap(baseField);
			var bfIsObject = !bfIsArray && !bfIsMap && dropecho_interop_Extender.isObject(baseField);
			if(bfIsArray) {
				var copy = dropecho_interop_AbstractArray.fromAny(exField);
				var _g4 = 0;
				var _g5 = copy;
				while(_g4 < _g5.length) {
					var v = _g5[_g4];
					++_g4;
					baseField.push(v);
				}
			} else if(bfIsMap) {
				var copy1 = dropecho_interop_AbstractMap.fromAny(exField);
				var _g6 = haxe_ds_StringMap.kvIterator(copy1.h);
				while(_g6.hasNext()) {
					var _g7 = _g6.next();
					var k = _g7.key;
					var v1 = _g7.value;
					baseField.set(k,v1);
				}
			} else if(bfIsObject) {
				dropecho_interop_Extender.defaults(baseField,exField);
			} else {
				try {
					base[ff] = exField;
				} catch( _g8 ) {
					var ex1 = haxe_Exception.caught(_g8).unwrap();
					console.log("dropecho/interop/Extender.hx:87:","FAILED SETTING PROP: " + ff + " error: " + Std.string(ex1));
				}
			}
		}
	}
	return base;
};
dropecho_interop_Extender.isObject = function(obj) {
	var stdis = Reflect.isObject(obj);
	var type = js_Boot.getClass(obj);
	var name = type != null ? type.__name__ : "";
	var refis = name != "String";
	if(stdis) {
		return refis;
	} else {
		return false;
	}
};
dropecho_interop_Extender.isArray = function(obj) {
	return ((obj) instanceof Array);
};
dropecho_interop_Extender.isMap = function(obj) {
	if(((obj) instanceof Map)) {
		return true;
	}
	var type = js_Boot.getClass(obj);
	var name = type != null ? type.__name__ : "";
	if(name == null) {
		name = "";
	}
	var isMap = StringTools.startsWith(name,"haxe.ds.") && StringTools.endsWith(name,"Map");
	return isMap;
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Int32 = {};
haxe_Int32.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
haxe__$Int64__$_$_$Int64.prototype = {
	high: null
	,low: null
	,__class__: haxe__$Int64__$_$_$Int64
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Sha1 = function() {
};
haxe_crypto_Sha1.__name__ = "haxe.crypto.Sha1";
haxe_crypto_Sha1.make = function(b) {
	var h = new haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b));
	var out = new haxe_io_Bytes(new ArrayBuffer(20));
	var p = 0;
	out.b[p++] = h[0] >>> 24;
	out.b[p++] = h[0] >> 16 & 255;
	out.b[p++] = h[0] >> 8 & 255;
	out.b[p++] = h[0] & 255;
	out.b[p++] = h[1] >>> 24;
	out.b[p++] = h[1] >> 16 & 255;
	out.b[p++] = h[1] >> 8 & 255;
	out.b[p++] = h[1] & 255;
	out.b[p++] = h[2] >>> 24;
	out.b[p++] = h[2] >> 16 & 255;
	out.b[p++] = h[2] >> 8 & 255;
	out.b[p++] = h[2] & 255;
	out.b[p++] = h[3] >>> 24;
	out.b[p++] = h[3] >> 16 & 255;
	out.b[p++] = h[3] >> 8 & 255;
	out.b[p++] = h[3] & 255;
	out.b[p++] = h[4] >>> 24;
	out.b[p++] = h[4] >> 16 & 255;
	out.b[p++] = h[4] >> 8 & 255;
	out.b[p++] = h[4] & 255;
	return out;
};
haxe_crypto_Sha1.bytes2blks = function(b) {
	var nblk = (b.length + 8 >> 6) + 1;
	var blks = [];
	var _g = 0;
	var _g1 = nblk * 16;
	while(_g < _g1) {
		var i = _g++;
		blks[i] = 0;
	}
	var _g = 0;
	var _g1 = b.length;
	while(_g < _g1) {
		var i = _g++;
		var p = i >> 2;
		blks[p] |= b.b[i] << 24 - ((i & 3) << 3);
	}
	var i = b.length;
	var p = i >> 2;
	blks[p] |= 128 << 24 - ((i & 3) << 3);
	blks[nblk * 16 - 1] = b.length * 8;
	return blks;
};
haxe_crypto_Sha1.prototype = {
	doEncode: function(x) {
		var w = [];
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var e = -1009589776;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;
			var j = 0;
			while(j < 80) {
				if(j < 16) {
					w[j] = x[i + j];
				} else {
					var num = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
					w[j] = num << 1 | num >>> 31;
				}
				var t = (a << 5 | a >>> 27) + this.ft(j,b,c,d) + e + w[j] + this.kt(j);
				e = d;
				d = c;
				c = b << 30 | b >>> 2;
				b = a;
				a = t;
				++j;
			}
			a += olda;
			b += oldb;
			c += oldc;
			d += oldd;
			e += olde;
			i += 16;
		}
		return [a,b,c,d,e];
	}
	,ft: function(t,b,c,d) {
		if(t < 20) {
			return b & c | ~b & d;
		}
		if(t < 40) {
			return b ^ c ^ d;
		}
		if(t < 60) {
			return b & c | b & d | c & d;
		}
		return b ^ c ^ d;
	}
	,kt: function(t) {
		if(t < 20) {
			return 1518500249;
		}
		if(t < 40) {
			return 1859775393;
		}
		if(t < 60) {
			return -1894007588;
		}
		return -899497514;
	}
	,__class__: haxe_crypto_Sha1
};
var haxe_ds_ArraySort = function() { };
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	h: null
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(key | 0);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.valueIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return h[keys[idx - 1]];
	}};
};
haxe_ds_StringMap.kvIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		var k = keys[idx - 1];
		return { key : k, value : h[k]};
	}};
};
haxe_ds_StringMap.prototype = {
	h: null
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,data: null
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getInt64: function(pos) {
		var this1 = new haxe__$Int64__$_$_$Int64(this.getInt32(pos + 4),this.getInt32(pos));
		return this1;
	}
	,setInt64: function(pos,v) {
		this.setInt32(pos,v.low);
		this.setInt32(pos + 4,v.high);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var seedyrng_GeneratorInterface = function() { };
seedyrng_GeneratorInterface.__name__ = "seedyrng.GeneratorInterface";
seedyrng_GeneratorInterface.__isInterface__ = true;
seedyrng_GeneratorInterface.prototype = {
	get_seed: null
	,set_seed: null
	,get_state: null
	,set_state: null
	,get_usesAllBits: null
	,nextInt: null
	,__class__: seedyrng_GeneratorInterface
};
var seedyrng_Random = function(seed,generator) {
	if(seed == null) {
		var this1 = new haxe__$Int64__$_$_$Int64(seedyrng_Random.randomSystemInt(),seedyrng_Random.randomSystemInt());
		seed = this1;
	}
	if(generator == null) {
		generator = new seedyrng_Xorshift128Plus();
	}
	this.generator = generator;
	this.set_seed(seed);
};
seedyrng_Random.__name__ = "seedyrng.Random";
seedyrng_Random.__interfaces__ = [seedyrng_GeneratorInterface];
seedyrng_Random.randomSystemInt = function() {
	var value = Std.random(255) << 24 | Std.random(255) << 16 | Std.random(255) << 8 | Std.random(255);
	return value;
};
seedyrng_Random.prototype = {
	generator: null
	,get_seed: function() {
		return this.generator.get_seed();
	}
	,set_seed: function(value) {
		return this.generator.set_seed(value);
	}
	,get_state: function() {
		return this.generator.get_state();
	}
	,set_state: function(value) {
		return this.generator.set_state(value);
	}
	,get_usesAllBits: function() {
		return this.generator.get_usesAllBits();
	}
	,nextInt: function() {
		return this.generator.nextInt();
	}
	,nextFullInt: function() {
		if(this.generator.get_usesAllBits()) {
			return this.generator.nextInt();
		} else {
			var num1 = this.generator.nextInt();
			var num2 = this.generator.nextInt();
			num2 = num2 >>> 16 | num2 << 16;
			return num1 ^ num2;
		}
	}
	,setStringSeed: function(seed) {
		this.setBytesSeed(haxe_io_Bytes.ofString(seed));
	}
	,setBytesSeed: function(seed) {
		var hash = haxe_crypto_Sha1.make(seed);
		this.set_seed(hash.getInt64(0));
	}
	,random: function() {
		var upper = this.nextFullInt() & 2097151;
		var lower = this.nextFullInt();
		var b = upper * Math.pow(2,32);
		var floatNum = UInt.toFloat(lower) + b;
		var result = floatNum * Math.pow(2,-53);
		return result;
	}
	,randomInt: function(lower,upper) {
		return Math.floor(this.random() * (upper - lower + 1)) + lower;
	}
	,uniform: function(lower,upper) {
		return this.random() * (upper - lower) + lower;
	}
	,choice: function(array) {
		return array[this.randomInt(0,array.length - 1)];
	}
	,shuffle: function(array) {
		var _g = 0;
		var _g1 = array.length - 1;
		while(_g < _g1) {
			var index = _g++;
			var randIndex = this.randomInt(index,array.length - 1);
			var tempA = array[index];
			var tempB = array[randIndex];
			array[index] = tempB;
			array[randIndex] = tempA;
		}
	}
	,__class__: seedyrng_Random
};
var seedyrng_Xorshift128Plus = function() {
	this._currentAvailable = false;
	var this1 = new haxe__$Int64__$_$_$Int64(0,1);
	this.set_seed(this1);
};
seedyrng_Xorshift128Plus.__name__ = "seedyrng.Xorshift128Plus";
seedyrng_Xorshift128Plus.__interfaces__ = [seedyrng_GeneratorInterface];
seedyrng_Xorshift128Plus.prototype = {
	_seed: null
	,_state0: null
	,_state1: null
	,_current: null
	,_currentAvailable: null
	,get_usesAllBits: function() {
		return false;
	}
	,get_seed: function() {
		return this._seed;
	}
	,set_seed: function(value) {
		var b_high = 0;
		var b_low = 0;
		if(!(value.high != b_high || value.low != b_low)) {
			var this1 = new haxe__$Int64__$_$_$Int64(0,1);
			value = this1;
		}
		this._seed = value;
		this._state0 = value;
		this._state1 = seedyrng_Xorshift128Plus.SEED_1;
		this._currentAvailable = false;
		return value;
	}
	,get_state: function() {
		var bytes = new haxe_io_Bytes(new ArrayBuffer(33));
		bytes.setInt64(0,this._seed);
		bytes.setInt64(8,this._state0);
		bytes.setInt64(16,this._state1);
		bytes.b[24] = this._currentAvailable ? 1 : 0;
		if(this._currentAvailable) {
			bytes.setInt64(25,this._current);
		}
		return bytes;
	}
	,set_state: function(value) {
		if(value.length != 33) {
			throw haxe_Exception.thrown("Wrong state size " + value.length);
		}
		this._seed = value.getInt64(0);
		this._state0 = value.getInt64(8);
		this._state1 = value.getInt64(16);
		this._currentAvailable = value.b[24] == 1;
		if(this._currentAvailable) {
			this._current = value.getInt64(25);
		}
		return value;
	}
	,stepNext: function() {
		var x = this._state0;
		var y = this._state1;
		this._state0 = y;
		var b = 23;
		b &= 63;
		var b1;
		if(b == 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high,x.low);
			b1 = this1;
		} else if(b < 32) {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high << b | x.low >>> 32 - b,x.low << b);
			b1 = this1;
		} else {
			var this1 = new haxe__$Int64__$_$_$Int64(x.low << b - 32,0);
			b1 = this1;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(x.high ^ b1.high,x.low ^ b1.low);
		x = this1;
		var a_high = x.high ^ y.high;
		var a_low = x.low ^ y.low;
		var b = 17;
		b &= 63;
		var b1;
		if(b == 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high,x.low);
			b1 = this1;
		} else if(b < 32) {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high >> b,x.high << 32 - b | x.low >>> b);
			b1 = this1;
		} else {
			var this1 = new haxe__$Int64__$_$_$Int64(x.high >> 31,x.high >> b - 32);
			b1 = this1;
		}
		var a_high1 = a_high ^ b1.high;
		var a_low1 = a_low ^ b1.low;
		var b = 26;
		b &= 63;
		var b1;
		if(b == 0) {
			var this1 = new haxe__$Int64__$_$_$Int64(y.high,y.low);
			b1 = this1;
		} else if(b < 32) {
			var this1 = new haxe__$Int64__$_$_$Int64(y.high >> b,y.high << 32 - b | y.low >>> b);
			b1 = this1;
		} else {
			var this1 = new haxe__$Int64__$_$_$Int64(y.high >> 31,y.high >> b - 32);
			b1 = this1;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(a_high1 ^ b1.high,a_low1 ^ b1.low);
		this._state1 = this1;
		var a = this._state1;
		var high = a.high + y.high | 0;
		var low = a.low + y.low | 0;
		if(haxe_Int32.ucompare(low,a.low) < 0) {
			var ret = high++;
			high = high | 0;
		}
		var this1 = new haxe__$Int64__$_$_$Int64(high,low);
		this._current = this1;
	}
	,nextInt: function() {
		if(this._currentAvailable) {
			this._currentAvailable = false;
			return this._current.low;
		} else {
			this.stepNext();
			this._currentAvailable = true;
			return this._current.high;
		}
	}
	,__class__: seedyrng_Xorshift128Plus
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = "String";
Array.__name__ = "Array";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
seedyrng_Xorshift128Plus.PARAMETER_A = 23;
seedyrng_Xorshift128Plus.PARAMETER_B = 17;
seedyrng_Xorshift128Plus.PARAMETER_C = 26;
seedyrng_Xorshift128Plus.SEED_1 = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(842650776,685298713);
	$r = this1;
	return $r;
}(this));
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
